(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{707:function(e,t,_){e.exports=_.p+"assets/img/decode.54ff7330.png"},708:function(e,t,_){e.exports=_.p+"assets/img/decode2.0c8981ca.png"},709:function(e,t,_){e.exports=_.p+"assets/img/decode3.4428e6af.png"},741:function(e,t,_){"use strict";_.r(t);var n=_(5),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"ffmpeg"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ffmpeg"}},[e._v("#")]),e._v(" FFmpeg")]),e._v(" "),n("blockquote",[n("p",[e._v("FFmpeg库")])]),e._v(" "),n("ul",[n("li",[e._v("avcodec：编解码（最重要的库）。")]),e._v(" "),n("li",[e._v("avformat：封装格式处理。")]),e._v(" "),n("li",[e._v("avfilter：滤镜特效处理。")]),e._v(" "),n("li",[e._v("avdevice：各种设备的输入输出。")]),e._v(" "),n("li",[e._v("avutil：工具库（大部分库都需要这个库的支持）。")]),e._v(" "),n("li",[e._v("postproc：后加工。")]),e._v(" "),n("li",[e._v("swresample：音频采样数据格式转换。")]),e._v(" "),n("li",[e._v("swscale：视频像素数据格式转换。")])]),e._v(" "),n("blockquote",[n("p",[e._v("FFmpeg解码的流程")])]),e._v(" "),n("p",[n("img",{attrs:{src:_(707),alt:"decode"}})]),e._v(" "),n("ul",[n("li",[e._v("av_register_all()：注册所有组件。")]),e._v(" "),n("li",[e._v("avformat_open_input()：打开输入视频文件。")]),e._v(" "),n("li",[e._v("avformat_find_stream_info()：获取视频文件信息。")]),e._v(" "),n("li",[e._v("avcodec_find_decoder()：查找解码器。")]),e._v(" "),n("li",[e._v("avcodec_open2()：打开解码器。")]),e._v(" "),n("li",[e._v("av_read_frame()：从输入文件读取一帧压缩数据。")]),e._v(" "),n("li",[e._v("avcodec_decode_video2()：解码一帧压缩数据。")]),e._v(" "),n("li",[e._v("avcodec_close()：关闭解码器。")]),e._v(" "),n("li",[e._v("avformat_close_input()：关闭输入视频文件。")])]),e._v(" "),n("blockquote",[n("p",[e._v("FFmpeg解码的数据结构")])]),e._v(" "),n("p",[n("img",{attrs:{src:_(708),alt:"decode2"}})]),e._v(" "),n("ul",[n("li",[e._v("AVFormatContext\n封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息。")]),e._v(" "),n("li",[e._v("AVInputFormat\n每种封装格式（例如FLV, MKV, MP4, AVI）对应一个该结构体。")]),e._v(" "),n("li",[e._v("AVStream\n视频文件中每个视频（音频）流对应一个该结构体。")]),e._v(" "),n("li",[e._v("AVCodecContext\n编码器上下文结构体，保存了视频（音频）编解码相关信息。")]),e._v(" "),n("li",[e._v("AVCodec\n每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体。")]),e._v(" "),n("li",[e._v("AVPacket\n存储一帧压缩编码数据。")]),e._v(" "),n("li",[e._v("AVFrame\n存储一帧解码后像素（采样）数据。")])]),e._v(" "),n("blockquote",[n("p",[e._v("FFmpeg数据结构分析")])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("AVFormatContext\niformat：输入视频的AVInputFormat\nnb_streams ：输入视频的AVStream 个数\nstreams ：输入视频的AVStream []数组\nduration ：输入视频的时长（以微秒为单位）\nbit_rate ：输入视频的码率")])]),e._v(" "),n("li",[n("p",[e._v("AVInputFormat\nname：封装格式名称\nlong_name：封装格式的长名称\nextensions：封装格式的扩展名\nid：封装格式ID\n一些封装格式处理的接口函数")])]),e._v(" "),n("li",[n("p",[e._v("AVStream\nid：序号\ncodec：该流对应的AVCodecContext\ntime_base：该流的时基\nr_frame_rate：该流的帧率")])]),e._v(" "),n("li",[n("p",[e._v("AVCodecContext\ncodec：编解码器的AVCodec\nwidth, height：图像的宽高（只针对视频）\npix_fmt：像素格式（只针对视频）\nsample_rate：采样率（只针对音频）\nchannels：声道数（只针对音频）\nsample_fmt：采样格式（只针对音频）")])]),e._v(" "),n("li",[n("p",[e._v("AVCodec\nname：编解码器名称\nlong_name：编解码器长名称\ntype：编解码器类型\nid：编解码器ID\n一些编解码的接口函数")])]),e._v(" "),n("li",[n("p",[e._v("AVPacket\npts：显示时间戳\ndts ：解码时间戳\ndata ：压缩编码数据\nsize ：压缩编码数据大小\nstream_index ：所属的AVStream")])]),e._v(" "),n("li",[n("p",[e._v("AVFrame\ndata：解码后的图像像素数据（音频采样数据）。\nlinesize：对视频来说是图像中一行像素的大小；对音频来说是整个音频帧的大小。\nwidth, height：图像的宽高（只针对视频）。\nkey_frame：是否为关键帧（只针对视频） 。\npict_type：帧类型（只针对视频） 。例如I，P，B。")]),e._v(" "),n("blockquote",[n("p",[e._v("tip")])])]),e._v(" "),n("li",[n("p",[e._v("解码后的数据为什么要经过sws_scale()函数处理？\n解码后YUV格式的视频像素数据保存在AVFrame的data[0]、data[1]、data[2]中。但是这些像素值并不是连续存储的，每行有效像素之后存储了一些无效像素 。 以亮度 Y 数据为例 ， data[0] 中一共包含了linesize[0]*height个数据。但是出于优化等方面的考虑，linesize[0]实际上并不等于宽度width，而是一个比宽度大一些的值。因此需要使用sws_scale()进行转换。转换后去除了无效数据，width和linesize[0]取值相等。\n"),n("img",{attrs:{src:_(709),alt:"decode3"}})])])])])}),[],!1,null,null,null);t.default=a.exports}}]);