(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{709:function(_,e,v){_.exports=v.p+"assets/img/decode.54ff7330.png"},710:function(_,e,v){_.exports=v.p+"assets/img/decode2.0c8981ca.png"},711:function(_,e,v){_.exports=v.p+"assets/img/decode3.4428e6af.png"},745:function(_,e,v){"use strict";v.r(e);var t=v(5),n=Object(t.a)({},(function(){var _=this,e=_.$createElement,t=_._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"ffmpeg"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ffmpeg"}},[_._v("#")]),_._v(" FFmpeg")]),_._v(" "),t("blockquote",[t("p",[_._v("FFmpeg库")])]),_._v(" "),t("ul",[t("li",[_._v("avcodec：编解码（最重要的库）。")]),_._v(" "),t("li",[_._v("avformat：封装格式处理。")]),_._v(" "),t("li",[_._v("avfilter：滤镜特效处理。")]),_._v(" "),t("li",[_._v("avdevice：各种设备的输入输出。")]),_._v(" "),t("li",[_._v("avutil：工具库（大部分库都需要这个库的支持）。")]),_._v(" "),t("li",[_._v("postproc：后加工。")]),_._v(" "),t("li",[_._v("swresample：音频采样数据格式转换。")]),_._v(" "),t("li",[_._v("swscale：视频像素数据格式转换。")])]),_._v(" "),t("blockquote",[t("p",[_._v("FFmpeg解码的流程")])]),_._v(" "),t("p",[t("img",{attrs:{src:v(709),alt:"decode"}})]),_._v(" "),t("ul",[t("li",[_._v("av_register_all()：注册所有组件。")]),_._v(" "),t("li",[_._v("avformat_open_input()：打开输入视频文件。")]),_._v(" "),t("li",[_._v("avformat_find_stream_info()：获取视频文件信息。")]),_._v(" "),t("li",[_._v("avcodec_find_decoder()：查找解码器。")]),_._v(" "),t("li",[_._v("avcodec_open2()：打开解码器。")]),_._v(" "),t("li",[_._v("av_read_frame()：从输入文件读取一帧压缩数据。")]),_._v(" "),t("li",[_._v("avcodec_decode_video2()：解码一帧压缩数据。")]),_._v(" "),t("li",[_._v("avcodec_close()：关闭解码器。")]),_._v(" "),t("li",[_._v("avformat_close_input()：关闭输入视频文件。")])]),_._v(" "),t("blockquote",[t("p",[_._v("FFmpeg解码的数据结构")])]),_._v(" "),t("p",[t("img",{attrs:{src:v(710),alt:"decode2"}})]),_._v(" "),t("ul",[t("li",[_._v("AVFormatContext\n封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息。")]),_._v(" "),t("li",[_._v("AVInputFormat\n每种封装格式（例如FLV, MKV, MP4, AVI）对应一个该结构体。")]),_._v(" "),t("li",[_._v("AVStream\n视频文件中每个视频（音频）流对应一个该结构体。")]),_._v(" "),t("li",[_._v("AVCodecContext\n编码器上下文结构体，保存了视频（音频）编解码相关信息。")]),_._v(" "),t("li",[_._v("AVCodec\n每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体。")]),_._v(" "),t("li",[_._v("AVPacket\n存储一帧压缩编码数据。")]),_._v(" "),t("li",[_._v("AVFrame\n存储一帧解码后像素（采样）数据。")])]),_._v(" "),t("blockquote",[t("p",[_._v("FFmpeg数据结构分析")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("AVFormatContext"),t("br"),_._v("\niformat：输入视频的AVInputFormat"),t("br"),_._v("\nnb_streams ：输入视频的AVStream 个数"),t("br"),_._v("\nstreams ：输入视频的AVStream []数组"),t("br"),_._v("\nduration ：输入视频的时长（以微秒为单位）"),t("br"),_._v("\nbit_rate ：输入视频的码率")])]),_._v(" "),t("li",[t("p",[_._v("AVInputFormat"),t("br"),_._v("\nname：封装格式名称"),t("br"),_._v("\nlong_name：封装格式的长名称"),t("br"),_._v("\nextensions：封装格式的扩展名"),t("br"),_._v("\nid：封装格式ID"),t("br"),_._v("\n一些封装格式处理的接口函数")])]),_._v(" "),t("li",[t("p",[_._v("AVStream"),t("br"),_._v("\nid：序号"),t("br"),_._v("\ncodec：该流对应的AVCodecContext"),t("br"),_._v("\ntime_base：该流的时基"),t("br"),_._v("\nr_frame_rate：该流的帧率")])]),_._v(" "),t("li",[t("p",[_._v("AVCodecContext"),t("br"),_._v("\ncodec：编解码器的AVCodec"),t("br"),_._v("\nwidth, height：图像的宽高（只针对视频）"),t("br"),_._v("\npix_fmt：像素格式（只针对视频）"),t("br"),_._v("\nsample_rate：采样率（只针对音频）"),t("br"),_._v("\nchannels：声道数（只针对音频）"),t("br"),_._v("\nsample_fmt：采样格式（只针对音频）")])]),_._v(" "),t("li",[t("p",[_._v("AVCodec"),t("br"),_._v("\nname：编解码器名称"),t("br"),_._v("\nlong_name：编解码器长名称"),t("br"),_._v("\ntype：编解码器类型"),t("br"),_._v("\nid：编解码器ID"),t("br"),_._v("\n一些编解码的接口函数")])]),_._v(" "),t("li",[t("p",[_._v("AVPacket"),t("br"),_._v("\npts：显示时间戳"),t("br"),_._v("\ndts ：解码时间戳"),t("br"),_._v("\ndata ：压缩编码数据"),t("br"),_._v("\nsize ：压缩编码数据大小"),t("br"),_._v("\nstream_index ：所属的AVStream")])]),_._v(" "),t("li",[t("p",[_._v("AVFrame"),t("br"),_._v("\ndata：解码后的图像像素数据（音频采样数据）。"),t("br"),_._v("\nlinesize：对视频来说是图像中一行像素的大小；对音频来说是整个音频帧的大小。"),t("br"),_._v("\nwidth, height：图像的宽高（只针对视频）。"),t("br"),_._v("\nkey_frame：是否为关键帧（只针对视频） 。"),t("br"),_._v("\npict_type：帧类型（只针对视频） 。例如I，P，B。")]),_._v(" "),t("blockquote",[t("p",[_._v("tip")])])]),_._v(" "),t("li",[t("p",[_._v("解码后的数据为什么要经过sws_scale()函数处理？"),t("br"),_._v("\n解码后YUV格式的视频像素数据保存在AVFrame的data[0]、data[1]、data[2]中。但是这些像素值并不是连续存储的，每行有效像素之后存储了一些无效像素 。 以亮度 Y 数据为例 ， data[0] 中一共包含了linesize[0]*height个数据。但是出于优化等方面的考虑，linesize[0]实际上并不等于宽度width，而是一个比宽度大一些的值。因此需要使用sws_scale()进行转换。转换后去除了无效数据，width和linesize[0]取值相等。\n"),t("img",{attrs:{src:v(711),alt:"decode3"}})])])])])}),[],!1,null,null,null);e.default=n.exports}}]);